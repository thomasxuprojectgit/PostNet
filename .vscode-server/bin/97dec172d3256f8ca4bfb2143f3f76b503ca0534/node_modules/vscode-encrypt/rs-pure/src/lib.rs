use chacha20poly1305::{
    aead::{Aead, KeyInit},
    ChaCha20Poly1305, KeySizeUser, Nonce,
};
use lazy_static::lazy_static;
use rand::Rng;
use sha2::{
    digest::{FixedOutputReset, HashMarker},
    Digest, Sha256,
};

const SALT: [u8; 8] = [0xCF, 0x86, 0x46, 0x55, 0x69, 0x38, 0xC0, 0x71];
const NONCE_SEED_LENGTH: usize = 8;

lazy_static! {
    static ref NONCE_SIZE: usize = Nonce::default().len();
}

pub fn encrypt(key: &[u8], value: &[u8]) -> Result<String, Error> {
    let mut hashed_key = create_key(key)?;
    let nonce_seed: [u8; NONCE_SEED_LENGTH] = rand::thread_rng().gen::<u64>().to_be_bytes();
    hashed_key.extend_from_slice(&nonce_seed);

    let (key, iv) = evp_bytes_to_key::<Sha256>(
        &SALT[..],
        &hashed_key,
        1,
        ChaCha20Poly1305::key_size(),
        *NONCE_SIZE,
    );

    let mut enc = ChaCha20Poly1305::new_from_slice(&key)
        .expect("expected correct key size")
        .encrypt(Nonce::from_slice(&iv), value)
        .expect("expected to encrypt");
    enc.extend_from_slice(&nonce_seed);
    Ok(base64::encode(enc))
}

pub fn decrypt(key: &[u8], value: &str) -> Result<Vec<u8>, Error> {
    let enc = base64::decode(value).map_err(|_| Error("Invalid base64 data".to_string()))?;
    if enc.len() < NONCE_SEED_LENGTH {
        return Err(Error("Value too short".to_string()));
    }

    let mut nonce_seed: [u8; NONCE_SEED_LENGTH] = [0; NONCE_SEED_LENGTH];
    let nonce_start = enc.len() - NONCE_SEED_LENGTH;
    nonce_seed.copy_from_slice(&enc[nonce_start..]);

    let mut hashed_key = create_key(key)?;
    hashed_key.extend_from_slice(&nonce_seed);

    let (key, iv) = evp_bytes_to_key::<Sha256>(
        &SALT[..],
        &hashed_key,
        1,
        ChaCha20Poly1305::key_size(),
        *NONCE_SIZE,
    );

    let dec = ChaCha20Poly1305::new_from_slice(&key)
        .expect("expected correct key size")
        .decrypt(Nonce::from_slice(&iv), &enc[..nonce_start])
        .map_err(|_| Error::generic())?;

    Ok(dec)
}

#[cfg(unix)]
fn create_key(key: &[u8]) -> Result<Vec<u8>, Error> {
    let exe = std::env::current_exe().map_err(|_| Error::generic())?;
    let exe = exe.to_string_lossy();
    let mut exe = exe.as_ref();

    // SNAP is set to the directory where the snap is mounted when running in a snap package. This snap path has a version number in it
    // which can't be used to reliably encrypt/decrypt after a version update. to get around this, we check for the SNAP environment
    // variable and remove that from the process path. Whatâ€™s left over is /usr/bin/code (or similar) which is perfect to be used in the encryption.
    // More info: https://snapcraft.io/docs/environment-variables
    if cfg!(target_os = "linux") {
        if let Ok(snap) = std::env::var("SNAP") {
            if exe.contains(&snap) {
                exe = &exe[snap.len()..];
            }
        }
    }

    let mut hasher = Sha256::new();
    hasher.update(key);
    hasher.update(exe.as_bytes());
    Ok(hasher.finalize().to_vec())
}

#[cfg(windows)]
fn create_key(key: &[u8]) -> Result<Vec<u8>, Error> {
    let mut hasher = Sha256::new();
    hasher.update(key);
    hasher.update(b"33000001df6bf02e92a74ab4d00000000001df");
    Ok(hasher.finalize().to_vec())
}

pub fn evp_bytes_to_key<D: Default + HashMarker + FixedOutputReset>(
    salt: &[u8],
    data: &[u8],
    hashes: usize,
    key_bytes: usize,
    iv_bytes: usize,
) -> (Vec<u8>, Vec<u8>) {
    let byte_len = key_bytes + iv_bytes;
    let mut hasher = D::default();
    let mut derived_key = Vec::with_capacity(byte_len);
    let mut block = Vec::new();

    while derived_key.len() < byte_len {
        if !block.is_empty() {
            hasher.update(&block);
        }
        hasher.update(data);
        hasher.update(salt.as_ref());
        block = hasher.finalize_reset().to_vec();

        if hashes > 1 {
            for _ in 0..(hashes - 1) {
                hasher.update(&block);
                block = hasher.finalize_reset().to_vec();
            }
        }

        derived_key.extend_from_slice(&block);
    }

    (
        derived_key[0..key_bytes].to_vec(),
        derived_key[key_bytes..byte_len].to_vec(),
    )
}

#[derive(Debug)]
pub struct Error(String);

impl Error {
    /// Returns a generic errror -- used in many cases to avoid leaking
    /// internals about waht is used for state.
    fn generic() -> Error {
        Error("Cryptography failed".to_string())
    }
}

impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}

#[cfg(test)]
mod test {
    #[test]
    fn test_round_trips() {
        let input = &b"hello world!"[..];
        let key = &b"salt"[..];

        let encrypted = super::encrypt(key, input).expect("expected to encrypt");
        assert_ne!(encrypted, String::from_utf8_lossy(input));
        let decrypted = super::decrypt(key, &encrypted).expect("expected to decrypt");
        assert_eq!(&decrypted, input);
    }

    #[test]
    fn test_does_not_reuse_nonce() {
        let input = &b"hello world!"[..];
        let key = &b"salt"[..];

        let encrypted1 = super::encrypt(key, input).expect("expected to encrypt");
        let encrypted2 = super::encrypt(key, input).expect("expected to encrypt");
        assert_ne!(encrypted1, encrypted2);
    }

    #[test]
    fn test_different_salts_encrypt_different() {
        let input = &b"hello world!"[..];

        let encrypted = super::encrypt(&b"salt"[..], input).expect("expected to encrypt");
        assert_ne!(encrypted, String::from_utf8_lossy(input));
        super::decrypt(&b"pepper"[..], &encrypted).expect_err("expected *not* to decrypt");
    }
}
